import os
import json
import shutil
import tarfile
from typing import Optional

from dynamite_nsm import const
from dynamite_nsm import utilities
from dynamite_nsm.services.base import install

dynamite_bin = shutil.which('dynamite')

sudoers_patch = f'''
dynamite-remote ALL=(ALL) NOPASSWD: {dynamite_bin}
'''

ssh_config_patch = f'''
Match User dynamite-remote
    PasswordAuthentication no
    PubkeyAuthentication yes
'''


class InstallManager(install.BaseInstallManager):

    def __init__(self, install_directory: str, stdout: Optional[bool] = False, verbose: Optional[bool] = False):
        """Install a new remote manager authentication package
        Args:
            install_directory: Path to the install directory (E.G /opt/dynamite/remotes/)
            stdout: Print output to console
            verbose: Include detailed debug messages
        """
        super().__init__('remote.install', verbose, stdout)
        self.install_directory = install_directory

    @staticmethod
    def patch_sudoers():
        include_directory = utilities.get_sudoers_directory_path()
        if not include_directory:
            include_directory = const.SUDOERS_DIRECTORY
            utilities.makedirs(include_directory)
            with open(const.SUDOERS_FILE, 'a') as sudoers_out:
                sudoers_out.write(f'\n#includedir {include_directory}')
        with open(f'{include_directory}/dynamite-remote', 'w') as dynamite_sudoers_out:
            dynamite_sudoers_out.write(sudoers_patch)

    @staticmethod
    def patch_ssh_config():
        include_directory = utilities.get_sshd_directory_path()
        if not include_directory:
            include_directory = const.SSH_CONF_DIRECTORY
            utilities.makedirs(include_directory)
            with open(const.SSH_CONF_FILE, 'a') as ssh_config_out:
                ssh_config_out.write(f'\nInclude {include_directory}')
        with open(f'{include_directory}/dynamite-remote', 'w') as dynamite_ssh_config_out:
            dynamite_ssh_config_out.write(ssh_config_patch)

    def create_update_remote_environment_variables(self) -> None:
        """Creates all the required Zeek environmental variables
        Args:

        Returns:
            None
        """
        self.create_update_env_variable('REMOTES_HOME', self.install_directory)

    def setup(self, archive: Optional[str] = None) -> None:
        """ Install node to remotely manage this instance of DynamiteNSM

        Args:
            archive: The path to the tar.gz archive generated by the dynamite-remote utility.
        Returns:
            None
        """
        tar = tarfile.open(archive)
        metadata = json.load(tar.extractfile('metadata.json'))
        utilities.create_dynamite_remote_user()
        self.create_update_remote_environment_variables()
        remote_user_root = '/home/dynamite-remote/'
        pub_key_root = f'{remote_user_root}/.ssh/'
        pub_key_file_path = f'{pub_key_root}/authorized_keys'
        pub_key_content = tar.extractfile('key.pub').read()
        self.logger.debug(f'Creating directory: {self.install_directory}')
        utilities.makedirs(self.install_directory)
        self.logger.debug(f'Creating directory: {pub_key_root}')
        utilities.makedirs(pub_key_root)
        self.logger.debug(f'Setting permissions of {pub_key_root} to 700.')
        utilities.set_permissions_of_file(pub_key_root, 700)
        self.logger.debug(f'Setting up public key for {metadata["hostname"]}')

        # Install the public key
        self.logger.info(f'Installing public key for {metadata["hostname"]}')
        with open(pub_key_file_path, 'a') as pub_key_out:
            pub_key_out.write('\n' + pub_key_content.decode('utf-8'))
            self.logger.debug(f'Setting permissions of {pub_key_file_path} to 644.')
            utilities.set_permissions_of_file(pub_key_file_path, 644)

        # Install the metadata file
        with open(f'{self.install_directory}/{metadata["hostname"]}', 'w') as metadata_out:
            metadata_out.write(json.dumps(metadata))

        self.logger.debug(f'Setting ownership of {self.install_directory} to dynamite-remote.')
        utilities.set_ownership_of_file(self.install_directory, user='dynamite-remote', group='dynamite-remote')
        self.logger.debug(f'Setting ownership of {pub_key_file_path} to dynamite-remote.')
        utilities.set_ownership_of_file(remote_user_root, user='dynamite-remote', group='dynamite-remote')
        self.logger.debug('Patching sudoers file.')
        self.patch_sudoers()
        self.logger.debug('Patching sshd_config')
        self.patch_ssh_config()
        self.logger.info(f'{metadata["hostname"]} has been installed as a remote on this node. '
                         f'You can now access it via:'
                         f' \'dynamite-remote execute {metadata["node_name"]} <dynamite command>\'.')


class UninstallManager(install.BaseUninstallManager):
    """
    Uninstall Dynamite remote manager
    """

    def __init__(self, remote_name: Optional[str] = None, delete_remote_user: Optional[bool] = False,
                 stdout: Optional[bool] = False,
                 verbose: Optional[bool] = False):
        """ Uninstall a remote
        Args:
            remote_name: The name of the remote to uninstall
            delete_remote_user: If included, remove the dynamite-remote user.
            stdout: Print output to console
            verbose: Include detailed debug messages
        """
        self.remote_name = remote_name
        self.delete_remote_user = delete_remote_user
        super().__init__('remote.uninstall', [], stdout=stdout, verbose=verbose)

    def uninstall(self):
        remote_user_root = '/home/dynamite-remote/'
        pub_key_root = f'{remote_user_root}/.ssh/'
        pub_key_file_path = f'{pub_key_root}/authorized_keys'
        env_vars = utilities.get_environment_file_dict()
        remotes_directory = env_vars.get('REMOTES_HOME')

        if self.delete_remote_user:
            self.logger.info('Deleting dynamite-remote user.')
            utilities.delete_dynamite_remote_user()
        valid_names = os.listdir(remotes_directory)
        if not valid_names:
            self.logger.warning('No remotes are installed.')
        elif not self.remote_name:
            self.logger.info(f'Select from the following remotes to uninstall: {valid_names}')
            return
        elif self.remote_name not in valid_names:
            self.logger.warning(f'Invalid remote name given. Valid remotes are: {valid_names}')
            return

        new_file = ""
        with open(pub_key_file_path, 'r') as pub_keys_r:
            for auth_key in pub_keys_r.readlines():
                if self.remote_name in auth_key:
                    continue
                new_file += auth_key.strip() + '\n'
        with open(pub_key_file_path, 'w') as pub_keys_w:
            pub_keys_w.write(new_file)
        utilities.safely_remove_file(f'{remotes_directory}/{self.remote_name}')
        self.logger.info(f'Uninstalled {self.remote_name} remote.')
